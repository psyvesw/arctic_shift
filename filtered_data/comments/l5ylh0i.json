{
    "_meta": {
        "is_edited": true,
        "retrieved_2nd_on": 1716987180
    },
    "all_awardings": [],
    "approved_at_utc": null,
    "approved_by": null,
    "archived": false,
    "associated_award": null,
    "author": "Pillars-In-The-Trees",
    "author_flair_background_color": null,
    "author_flair_css_class": null,
    "author_flair_richtext": [],
    "author_flair_template_id": null,
    "author_flair_text": null,
    "author_flair_text_color": null,
    "author_flair_type": "text",
    "author_fullname": "t2_1ua4ai9j",
    "author_is_blocked": false,
    "author_patreon_flair": false,
    "author_premium": false,
    "awarders": [],
    "banned_at_utc": null,
    "banned_by": null,
    "body": "I just did a test by asking it top build me Minesweeper with one prompt. Here are the results:\n\nGPT 3.5:\n\n    import random\n    \n    def initialize_board(rows, cols, mines):\n        board = [[' ' for _ in range(cols)] for _ in range(rows)]\n        mine_locations = random.sample(range(rows * cols), mines)\n        for loc in mine_locations:\n            row = loc // cols\n            col = loc % cols\n            board[row][col] = '*'\n        return board\n    \n    def print_board(board):\n        for row in board:\n            print(' | '.join(row))\n            print('-' * (4 * len(row) - 1))\n    \n    def count_adjacent_mines(board, row, col):\n        count = 0\n        for i in range(max(0, row - 1), min(len(board), row + 2)):\n            for j in range(max(0, col - 1), min(len(board[0]), col + 2)):\n                if board[i][j] == '*':\n                    count += 1\n        return count\n    \n    def reveal_empty_cells(board, revealed, row, col):\n        if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]) or revealed[row][col]:\n            return\n        revealed[row][col] = True\n        if board[row][col] != ' ':\n            return\n        for i in range(row - 1, row + 2):\n            for j in range(col - 1, col + 2):\n                reveal_empty_cells(board, revealed, i, j)\n    \n    def play_game(rows, cols, mines):\n        board = initialize_board(rows, cols, mines)\n        revealed = [[False for _ in range(cols)] for _ in range(rows)]\n        game_over = False\n    \n        while not game_over:\n            print_board(revealed)\n            row = int(input(\"Enter row: \"))\n            col = int(input(\"Enter column: \"))\n    \n            if board[row][col] == '*':\n                print(\"Game Over! You hit a mine!\")\n                game_over = True\n            else:\n                if not revealed[row][col]:\n                    revealed[row][col] = True\n                    if board[row][col] == ' ':\n                        reveal_empty_cells(board, revealed, row, col)\n    \n                remaining_tiles = sum(1 for row in revealed for tile in row if not tile)\n                if remaining_tiles == mines:\n                    print(\"Congratulations! You've won!\")\n                    game_over = True\n    \n    # Example usage\n    rows = 8\n    cols = 8\n    mines = 10\n    play_game(rows, cols, mines)\n\nGPT 4o:\n\n    import random\n    \n    class Minesweeper:\n        def __init__(self, rows, cols, mines):\n            self.rows = rows\n            self.cols = cols\n            self.mines = mines\n            self.board = [[0 for _ in range(cols)] for _ in range(rows)]\n            self.revealed = [[False for _ in range(cols)] for _ in range(rows)]\n            self.place_mines()\n            self.calculate_adjacent_mines()\n    \n        def place_mines(self):\n            mines_placed = 0\n            while mines_placed < self.mines:\n                row = random.randint(0, self.rows - 1)\n                col = random.randint(0, self.cols - 1)\n                if self.board[row][col] != -1:\n                    self.board[row][col] = -1\n                    mines_placed += 1\n    \n        def calculate_adjacent_mines(self):\n            for row in range(self.rows):\n                for col in range(self.cols):\n                    if self.board[row][col] == -1:\n                        continue\n                    mines_count = 0\n                    for r in range(max(0, row - 1), min(self.rows, row + 2)):\n                        for c in range(max(0, col - 1), min(self.cols, col + 2)):\n                            if self.board[r][c] == -1:\n                                mines_count += 1\n                    self.board[row][col] = mines_count\n    \n        def reveal(self, row, col):\n            if self.revealed[row][col]:\n                return False\n            self.revealed[row][col] = True\n            if self.board[row][col] == -1:\n                return True\n            if self.board[row][col] == 0:\n                for r in range(max(0, row - 1), min(self.rows, row + 2)):\n                    for c in range(max(0, col - 1), min(self.cols, col + 2)):\n                        if not self.revealed[r][c]:\n                            self.reveal(r, c)\n            return False\n    \n        def print_board(self, reveal_all=False):\n            for row in range(self.rows):\n                for col in range(self.cols):\n                    if reveal_all or self.revealed[row][col]:\n                        if self.board[row][col] == -1:\n                            print('*', end=' ')\n                        else:\n                            print(self.board[row][col], end=' ')\n                    else:\n                        print('.', end=' ')\n                print()\n    \n        def is_won(self):\n            for row in range(self.rows):\n                for col in range(self.cols):\n                    if self.board[row][col] != -1 and not self.revealed[row][col]:\n                        return False\n            return True\n    \n    def play_minesweeper(rows=10, cols=10, mines=10):\n        game = Minesweeper(rows, cols, mines)\n        while True:\n            game.print_board()\n            row = int(input(\"Enter row: \"))\n            col = int(input(\"Enter col: \"))\n            if game.reveal(row, col):\n                print(\"Game over! You hit a mine!\")\n                game.print_board(reveal_all=True)\n                break\n            if game.is_won():\n                print(\"Congratulations! You've cleared all the mines!\")\n                game.print_board(reveal_all=True)\n                break\n    \n    if __name__ == \"__main__\":\n        play_minesweeper()\n\nIMO just based on that cursory test I'd say 4o has way better logic.",
    "can_gild": false,
    "can_mod_post": false,
    "collapsed": false,
    "collapsed_because_crowd_control": null,
    "collapsed_reason": null,
    "collapsed_reason_code": null,
    "comment_type": null,
    "controversiality": 0,
    "created": 1716857572,
    "created_utc": 1716857572,
    "distinguished": null,
    "downs": 0,
    "edited": false,
    "gilded": 0,
    "gildings": {},
    "id": "l5ylh0i",
    "is_submitter": false,
    "likes": null,
    "link_id": "t3_1d1r1ac",
    "locked": false,
    "mod_note": null,
    "mod_reason_by": null,
    "mod_reason_title": null,
    "mod_reports": [],
    "name": "t1_l5ylh0i",
    "no_follow": true,
    "num_reports": null,
    "parent_id": "t1_l5xws62",
    "permalink": "/r/ChatGPT/comments/1d1r1ac/study_finds_that_52_percent_of_chatgpt_answers_to/l5ylh0i/",
    "removal_reason": null,
    "replies": "",
    "report_reasons": null,
    "retrieved_on": 1716857590,
    "saved": false,
    "score": 1,
    "score_hidden": false,
    "send_replies": true,
    "stickied": false,
    "subreddit": "ChatGPT",
    "subreddit_id": "t5_7hqomg",
    "subreddit_name_prefixed": "r/ChatGPT",
    "subreddit_type": "public",
    "top_awarded_type": null,
    "total_awards_received": 0,
    "treatment_tags": [],
    "unrepliable_reason": null,
    "ups": 1,
    "user_reports": []
}